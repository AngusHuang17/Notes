## 面向对象基础

### 1. 面向对象的基本概念

面向对象=对象+分类+继承+通过消息的通信

#### 1.1 对象

 对象是基本的运行时的实体，它包括数据(属性)和作用于数据的操作(行为)。

一个对象通常由对象名、属性、方法组成

#### 1.2 消息

对象之间进行通信的一种构造叫做消息

#### 1.3 类

一个类定义了一组大体上相似的对象。类是对象之上的抽象，对象是类的具体化，是类的实例。

类的分类

- 实体类：表示现实世界中真正的实体
- 接口类（边界类）：为用户提供一种与系统合作交互的方式，分为人和系统两大类。
- 控制类：控制活动流，充当协调者。

#### 1.4 继承

继承是父类和子类之间共享数据和方法的机制。

子类从单个父类继承叫“单重继承”，有两个或更多的父类，称为“多重继承”。

#### 1.5 多态

不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态。

**参数多态**和**包含多态**称为通用的多态，**过载多态**和**强制多态**称为特定的多态。

### 2. 面向对象分析(OOA)

面向对象分析包括5个活动：认定对象、组织对象、描述对象的相互作用、确定对象的操作、定义对象的内部消息

### 3. 面向对象设计(OOD)

#### 3.1 面向对象设计原则

- 单一责任原则：就一个类而言，应该仅有一个引起他变化的原因
- 开放-封闭原则：软件实体（类、模块、函数）是可扩展的（开放），但是不可修改的（封闭）
- 里氏替换原则：子类型必须能够替换掉他们的基类型
- 依赖倒置原则：抽象不应该以来于细节，细节不应该依赖于抽象，即高层模块不应该依赖于低层模块，二者都应该依赖于抽象
- 接口分离原则：不应该强迫客户依赖于他们不用的方法。即依赖于抽象，不要依赖于具体。这样的好处是可以最大限度地应对可能的变化

#### 3.2 **对象和类的关系**

对象和类的**本质区别是：对象之间通过消息传递方式进行通信**

重置：在子类中重新定义父类中已经定义的方法

类属类：是关于一组类的一个特性抽象，强调的是这些类的成员特性中与具体类型无关的那些部分，比如卡车、面包车、救护车都是属于汽车，汽车就是一个类属类

### 3.3 面向对象测试

面向对象软件的测试可分为下列4个层次进行

- 算法层。测试类中定义的每个方法
- 类层。测试封装在同一个类中的所有方法与属性之间的作用关系
- 模板层。测试一组协同工作的类之间的相互作用
- 系统层。把各个子系统组装成完整的面向对象软件系统，在组装过程中同时进行测试。



## UML

UML三要素：UML的基本构造块、支配这些构造块如何放置在一起的规则、运用与整个语言的一些公共机制。

UML词汇表包含3种构造块：事物、关系、图

### 1. 事物

UML中有4种事物：结构事物、行为事物、分组事物、注释事物

#### 1.1 结构事物

通常是模型的静态部分，描述概念或物理元素。

结构事物包括：类(Class)、接口(Interface)、协作(Collaboration)、用例(Use Case)、主动类(Active Class)、构件(Component)、制品(Artifact)、结点(Node)。

#### 1.2 行为事物

行为事物是UML模型的动态部分，描述了跨越时间和空间的行为。

行为事物包括：交互、状态机、活动

#### 1.3 分组事物

是UML模型的组织部分，是一些由模型分解成的“盒子”。最主要的分组事物是包。

#### 1.4 注释事物

是UML模型的结束部分



### 2. 关系

UML中有4种关系：依赖、关联、泛化、实现

#### 2.1 依赖

依赖是两个事物间的语义关系，其中一个事物（独立事物）发生变化会影响另一个事物（依赖事物）的语义。

在图形上，依赖是一条**可能有方向的虚线**

#### 2.2 关联

关联是一种结构关系，它描述了一组链，链是对象之间的连接。聚集是一种特殊类型的关联，它描述了整体和部分间的结构关系

#### 2.3 泛化

泛化是一种特殊/一般关系，特殊元素（子元素）的对象可替代一般元素（父元素）的对象。

在图形上，泛化关系是一条带有空心箭头的实线，它指向父元素。

#### 2.4 实现

实现是类元之间的语义关系，其中一个类元指向了由另一个类元保证执行的契约。

### 3. 图

大多数情况下把图画成顶点（代表事物）和弧（代表关系）的连通图。

UML提供了13种图。分别是类图、对象图、用例图、序列图、通信图、状态图、活动图、构件图、组合结构图、部署图、包图、交互概览图 、计时图。序列图、通信图、交互概览图和计时图均被称为交互图

#### 3.1 类图

类图展现了一组对象、接口、协作和它们之间的关系

#### 3.2 对象图

对象图展现了某一时刻一组对象以及它们之间的关系，描述了在类图中所建立的事物的实例的惊天快照。对象图一般包括对象和链。

#### 3.3 用例图

用例图展现了一组用例、参与者、以及它们之间的关系（扩展关系（<<extend>>）、包含关系（<<include>>））。

#### 3.4 交互图

交互图用于对系统的动态方面进行建模。

#### 3.5 状态图

状态图展现了一个状态机，它由状态、转换、事件和活动组成

#### 3.6 活动图

活动图是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程。

#### 3.7 构件图

构件图展现了一组构件之间的组织和依赖。

#### 3.8 组合结构图

用于描述一个分类器的内部结构。

#### 3.9 部署图

用来对面向对象系统的物理方面建模的方法，展现了运行时处理结点以及其中构件的配置

#### 3.10 包图

用于把模型本身组织成层次结构的通用机制，不能执行，展现由模型本身分解而成的组织单元以及其间的依赖关系。

## 设计模式

### 1. 设计模式的4个基本要素

1. 模式名称。
2. 问题。问题描述了应该在何时使用模式。
3. 解决方案。解决方案描述了设计的组成成分、他们之间的相互关系及各自的职责和协作方式。
4. 效果。效果描述了模式应用的效果及使用模式应权衡的问题

### 2. 分类

按照设计模式的目的可以分为三类

1. 创建型模式。该模式与对象的创建有关
2. 结构型模式。结构型模式处理类或对象的组合
3. 行为型模式。行为型模式对类或对象这样交互和怎样分配职责进行描述

### 3. 创建型设计模式

创建型模式抽象了实例化过程，他们帮助一个系统独立于如何创建、组合和表示它的那些对象。

1. Abstract Factory (抽象工厂)。提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类
2. Builder (生成器)。讲一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示
3. Factory Method (工厂方法)。定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类
4. Prototype (原型)。用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象
5. Singleton (单例)。保证一个类仅有一个实例，并提供一个访问它的全局访问点

###  4. 结构型设计模式

结构型设计模式涉及如何组合类和对象以获得更大的结构

1. Adapter (适配器)。将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
2. Bridge (桥接)。将抽象部分与其实现部分分离，使它们可以独立的变化
3. Composite (组合)。将对象组合成树型结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性
4. Decorator (装饰)。动态的给一个对象添加一些额外的职责。就增加功能而言，Decorator模式比生成子类更加灵活
5. Facade (外观)。为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这以子系统更加容易使用
6. Flyweight (享元)。运用共享技术有效的支持大量细粒度的对象
7. Proxy (代理)。为其他对象提供一种代理以控制这个对象的访问

### 5. 行为设计模式

1. Chain of Responsibility (责任链)。是多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。
2. Command (命令)。将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化；对请求排队或记录请求记录，以及支持可撤销的操作。
3. Interpreter (解释器)。给定一个原因，定义他的文法的一种表示，并定义一个解释器，这个解释器使得该表示来解释语言中的句子
4. Iterator (迭代器)。提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示
5. Mediator（中介者）。用一个中介对象来封装一系列的对象的交互。中介者使各对象不需要显示的相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互
6. Memento（备忘录）。在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象恢复到原先保存的状态
7. Observer（观察者）。定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
8. State（状态）。允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类
9. Strategy（策略）。定义一系列的算法，把他们一个个封装起来，并且使它们可以相互替换。此模式使得算法可以独立于使用它们的客户而变化。
10. Template Method（魔板方法）。定义一个操作中的算法骨架，而将一些步骤延迟到子类中
11. Visitor （访问者）。表示一个作用于某个对象结构中的各元素的操作。





















































