### 1. 继承

####         1.1 格式

> `class 子类 extends 父类 {...}`

####            1.2 成员变量的访问

> ```java
> class Parent {
>     int num = 30;
> }
> ```
>
> ```java
> class Chidren extends Parent {
>     int num = 20;
>     public void printNum() {
>         // 访问父类的成员变量
>         System.out.println(super.num);
>         System.out.println(this.num);
>     }
> }
> ```

####         1.3 重写

> 1. 子类要重写父类的方法，最好在方法上加一行@Override，这句话只是一个提醒的作用。另外，如果加了这句话，那么重写的方法和参数如果错了的话，会报错。
>
> 2. 返回值范围要小于等于父类的
>
> 3. 修饰符权限要大于等于父类的
>
> public > protected > (default) > private
>
>  4. 重写的方法中，会自动覆盖父类的方法，所以若是要在父类的基础上增加功能，那么在子类的方法中应该加上super.父类方法();
>
>  5. 子类和父类的构造方法
>
>     1. 子类的构造方法中有一个默认隐含的“super()”调用，所以一定是先调用父类的构造，后执行子类的构造
>
>        例如：
>
>        父类中的构造 public Parent() {System.out.println("hello, parent")};
>
>        子类中的构造public Children() {System.out.println("hello, children")};
>
>        创建对象。Children c = new Children()
>
>        结果是：
>
>        hello, parent
>
>        hello, children
>
>     2. 子类构造可以通过super关键字来调用父类重载构造
>
>     3. super的父类调用构造，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造
>    
>     4. 子类必须调用父类的构造方法，不写则赠送一个super();写了则用写的super调用，super只能有一个，必须是第一个。

### 2. 抽象类

####         2.1 抽象方法和抽象类

> 抽象方法格式：public abstract void eat();  //　没有方法体
>
> 抽象类格式：　public abstract class Animal {...}

####         2.2 抽象类和抽象方法的使用

> 1. 不能直接new创建抽象类对象
>
> 2. 必须用一个子类来继承抽象父类
>
> 3. 子类中必须重写抽象类中的所有抽象方法
>
> 4. 创建子类对象使用
>
>    ```java
>    // 定义一个抽象类
>    public abstract class Animal {
>        public abstract void eat();
>    }
>    ```
>
>    ```java
>    // 定义上面抽象类的子类
>    publc class Cat extends Animal {
>        @Override
>        public void eat() {
>            System.out.println("猫正在吃东西");
>        }
>    }
>    ```

### 3. 接口

####     3.1 抽象方法定义

> 1. 格式：public  abstract  返回值类型  方法名(参数列表);
>
> 2. 注意：
>
>       修饰符必须是public  abstract，不能是private等其他修饰符。
>
>       这两个关键字修饰符，可以选择性省略

####     3.2 接口使用步骤

> 1. 接口不能直接使用，必须有一个实现类来实现该接口
>
>       格式：public class implements 接口名称 {...}
>
>  2. 实现类中必须重写接口中所有的抽象方法

####     3.3 接口的默认方法定义

> 1. 格式：public class 实现类名称 implements 接口名称 {...}
>
> 该方法用来接口接口升级问题
>
> 2. 默认方法会被实现类自动继承，该方法可以直接用接口类调用，也可以用接口的实现类对象调用

####     3.4 接口的静态方法

> 1. 格式：public static 返回值类型 方法名(参数列表) {...}
> 2. 使用：不能通过实现类对象调用，只能用接口名称调用

####     3.5 接口的私有方法（Java 9 之后才能使用）

> 1. 格式：private 返回值类型 方法名(参数列表) {...}
> 2. 使用：只提供奔雷中其他方法调用，不能在实现对象中使用

### 4. 内部类

####     4.1 成员内部类

