### 1. 关于子类和父类的构造器

1. 子类中的构造函数会自动调用父类中的构造函数，默认调用super()，即无参构造器

```java
class Demo3A {
    public String name;
    public Demo3A(String name) {
        this.name = name;
    }
}

class Demo3B extends Demo3A {
	public int id;
	public Demo3B(int id) {
        // 隐藏的super()
		this.id = id;
	}
}
```

该代码会报错，因为子类中的构造器会自动调用父类中的super()，但是父类中有没有无参构造器。



### 2. 关于接口、继承

1. 接口之间可以多继承

   ```java
   public interface A {}
   public interface B {}
   public interface C extends A,B {}
   ```



### 3. 关键字和修饰符(final、static)

1. final关键字修饰的变量为常量，只能被一次赋值，如果尝试第二次赋值，编译报错
2. 由于static在调用时没有当前的对象this，因此在static方法中不能对非static成员(当前对象的属性和方法)进行访问，但是非static方法可以访问static成员。
    也就是一个类中的**静态方法不可以调用非静态方法，但是非静态方法可以调用静态方法。**
    **静态方法不能访问非静态成员（非静态(成员、方法)的访问默认有一个this.，即非静态是与实例相关的），非静态方法可以访问静态成员**

### 4. static的题目

1. 需求：运行Demo这个类输出的结果是:1,2,3,4。在Xoo类中添加代码实现需求

   ```java
   public class Demo{
        public static void main(String[] args){
   		Xoo x1 = new Xoo();
   		Xoo x2 = new Xoo();
   		Xoo x3 = new Xoo();
   		Xoo x4 = new Xoo();
   		System.out.println(x1+","+x2+","+x3+","+x4)
        }	
   }
   class Xoo{
        public Xoo(){
        }
   }
   ```

2. 代码实现

   ```java
   class Xoo {
       public static int count;
       int index;
       public Xoo(){
           index = ++count;
       }
       @Override
       public String toString(){
           return Integer.toString(index);
       }
   }
   ```

### 5. 字符串拼接

例题: `System.out.println(1+2+"hello"+3+4)`的结果是什么

答案是: 3hello34

原因: 一开始的1+2会被当做整数的加法来计算; 加法加完之后变成了3+"hello"+3+4, 这儿牵涉到字符串的拼接问题,先计算3+"hello", 因为字符串本身是不会变的, 如果变了,那就只能是产生了新的字符串, 所以这儿实际是开辟了另一个字符数组空间来存储3+"hello", 那么结果就是"3hello"; 然后又变成了"3hello"+3, 这又是字符串的拼接,结果还是一个字符串, 所以最终的结果是"3hello34"






























